/**
 * Judge Module - Aggregation and Merge Logic
 * MVP v0.1 - Merge scanner outputs into ONE final review
 */

import type { OpenRouterConfig, ChatMessage } from '../openrouter/client.js';
import { callOpenRouter } from '../openrouter/client.js';
import type { ScannerResult } from './scanner.js';
import { logger } from '../utils/logger.js';

export interface JudgeConfig {
  openrouter: OpenRouterConfig;
  model: string;
  maxTokens: number;
  language: string;
}

export interface JudgeResult {
  output: string;
  tokensUsed: number;
  durationMs: number;
  success: boolean;
  error?: string | undefined;
}

/**
 * Get language instruction for system prompt
 */
function getLanguageInstruction(language: string): string {
  const lang = language.toLowerCase();

  if (lang === 'turkish' || lang === 'tr') {
    return 'You MUST respond in Turkish. Tüm çıktılarınız Türkçe olmalıdır. Bu çok önemli.';
  }

  if (lang === 'english' || lang === 'en') {
    return 'You MUST respond in English.';
  }

  return `You MUST respond in ${language}.`;
}

/**
 * Build judge system prompt
 */
function buildSystemPrompt(language: string): string {
  const languageInstruction = getLanguageInstruction(language);

  return `You are an expert code review aggregator. Your job is to:

1. **Merge** findings from multiple AI reviewers into a single, coherent review
2. **Deduplicate** similar issues - don't repeat the same finding
3. **Rank** issues by severity: Critical > High > Medium > Low
4. **Synthesize** - create a unified narrative, not just a list

IMPORTANT RULES:
- Do NOT add new findings that weren't mentioned by the reviewers
- Do NOT make up issues - only synthesize what was provided
- If reviewers disagree, note the disagreement
- Be concise but comprehensive

${languageInstruction}

Output format:
- Start with a brief summary (2-3 sentences)
- List issues by severity with clear explanations
- End with an overall assessment

Do NOT include any JSON formatting. Output plain text only.`;
}

/**
 * Build judge user prompt from scanner results
 */
function buildUserPrompt(scannerResults: ScannerResult[]): string {
  const successfulResults = scannerResults.filter((r) => r.success);

  if (successfulResults.length === 0) {
    return 'No scanner results available. Please indicate that the review could not be completed.';
  }

  const reviewsText = successfulResults
    .map((r) => `### Review from ${r.model}\n\n${r.output}`)
    .join('\n\n---\n\n');

  return `The following code reviews were generated by different AI models.
Merge them into a single, comprehensive review.

${reviewsText}

---

Now provide a unified, merged code review that:
1. Combines all unique findings
2. Removes duplicates
3. Ranks issues by severity
4. Provides a clear overall assessment`;
}

/**
 * Run the judge to merge scanner outputs
 */
export async function runJudge(
  config: JudgeConfig,
  scannerResults: ScannerResult[]
): Promise<JudgeResult> {
  const start = performance.now();

  const successfulScanners = scannerResults.filter((r) => r.success);

  logger.info('Starting judge aggregation', {
    judgeModel: config.model,
    scannersToMerge: successfulScanners.length,
    language: config.language,
  });

  if (successfulScanners.length === 0) {
    logger.error('No successful scanner results to judge');
    return {
      output: 'Review could not be completed - all scanners failed.',
      tokensUsed: 0,
      durationMs: Math.round(performance.now() - start),
      success: false,
      error: 'No successful scanner results',
    };
  }

  try {
    const messages: ChatMessage[] = [
      { role: 'system', content: buildSystemPrompt(config.language) },
      { role: 'user', content: buildUserPrompt(scannerResults) },
    ];

    const { content, tokensUsed } = await callOpenRouter(
      config.openrouter,
      config.model,
      messages,
      config.maxTokens,
      0.2 // Lower temperature for more consistent merging
    );

    const durationMs = Math.round(performance.now() - start);

    logger.info('Judge finished', {
      tokensUsed,
      durationMs,
      outputLength: content.length,
    });

    return {
      output: content,
      tokensUsed,
      durationMs,
      success: true,
    };
  } catch (error) {
    const durationMs = Math.round(performance.now() - start);
    const errorMessage = error instanceof Error ? error.message : String(error);

    logger.error('Judge failed', { error: errorMessage, durationMs });

    return {
      output: `Review aggregation failed: ${errorMessage}`,
      tokensUsed: 0,
      durationMs,
      success: false,
      error: errorMessage,
    };
  }
}
