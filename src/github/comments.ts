/**
 * GitHub Comments Module - Summary and Inline Comment Writer
 */

import { Octokit } from '@octokit/rest';
import type { GitHubConfig, ReviewComment, PostCommentOptions } from './types.js';
import type { FinalReview, Finding } from '../review/types.js';
import type { OutputLanguage } from '../review/prompts.js';
import { getSectionHeaders } from '../review/prompts.js';
import { logger } from '../utils/logger.js';

/** Localized UI strings */
const UI_STRINGS: Record<OutputLanguage, {
  header: string;
  stats: string;
  noFindings: string;
  noFindingsDesc: string;
  suggestion: string;
  verdictApprove: string;
  verdictRequestChanges: string;
  verdictComment: string;
  footer: string;
  cost: string;
}> = {
  en: {
    header: 'AI Code Review',
    stats: 'Statistics',
    noFindings: 'No Issues Found',
    noFindingsDesc: 'No significant issues were detected in the code review.',
    suggestion: 'Suggestion',
    verdictApprove: '**APPROVED** - Code is ready to merge',
    verdictRequestChanges: '**CHANGES REQUESTED** - Please address the findings',
    verdictComment: '**COMMENT** - Some suggestions for consideration',
    footer: 'This review was generated by {models} and aggregated by {judge}.',
    cost: 'Estimated cost',
  },
  tr: {
    header: 'AI Kod Ä°ncelemesi',
    stats: 'Ä°statistikler',
    noFindings: 'Bulgu Yok',
    noFindingsDesc: 'Kod incelemesinde Ã¶nemli bir sorun tespit edilmedi.',
    suggestion: 'Ã–neri',
    verdictApprove: '**ONAY** - Kod merge edilebilir',
    verdictRequestChanges: '**DEÄžÄ°ÅžÄ°KLÄ°K GEREKLÄ°** - LÃ¼tfen bulgularÄ± giderin',
    verdictComment: '**YORUM** - Ä°nceleme iÃ§in bazÄ± Ã¶neriler var',
    footer: 'Bu review {models} modelleri tarafÄ±ndan oluÅŸturuldu ve {judge} tarafÄ±ndan birleÅŸtirildi.',
    cost: 'Tahmini maliyet',
  },
  ja: {
    header: 'AIã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼',
    stats: 'çµ±è¨ˆ',
    noFindings: 'å•é¡Œãªã—',
    noFindingsDesc: 'ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§é‡è¦ãªå•é¡Œã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚',
    suggestion: 'ææ¡ˆ',
    verdictApprove: '**æ‰¿èª** - ãƒžãƒ¼ã‚¸å¯èƒ½ã§ã™',
    verdictRequestChanges: '**å¤‰æ›´è¦æ±‚** - æŒ‡æ‘˜äº‹é …ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„',
    verdictComment: '**ã‚³ãƒ¡ãƒ³ãƒˆ** - ã„ãã¤ã‹ã®ææ¡ˆãŒã‚ã‚Šã¾ã™',
    footer: 'ã“ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯{models}ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚Œã€{judge}ã«ã‚ˆã£ã¦é›†ç´„ã•ã‚Œã¾ã—ãŸã€‚',
    cost: 'æŽ¨å®šã‚³ã‚¹ãƒˆ',
  },
  de: {
    header: 'KI Code-Review',
    stats: 'Statistiken',
    noFindings: 'Keine Probleme',
    noFindingsDesc: 'Bei der Code-ÃœberprÃ¼fung wurden keine wesentlichen Probleme festgestellt.',
    suggestion: 'Vorschlag',
    verdictApprove: '**GENEHMIGT** - Code kann gemerged werden',
    verdictRequestChanges: '**Ã„NDERUNGEN ERFORDERLICH** - Bitte beheben Sie die Befunde',
    verdictComment: '**KOMMENTAR** - Einige VorschlÃ¤ge zur Ãœberlegung',
    footer: 'Dieses Review wurde von {models} erstellt und von {judge} zusammengefasst.',
    cost: 'GeschÃ¤tzte Kosten',
  },
  fr: {
    header: 'Revue de Code IA',
    stats: 'Statistiques',
    noFindings: 'Aucun ProblÃ¨me',
    noFindingsDesc: 'Aucun problÃ¨me significatif n\'a Ã©tÃ© dÃ©tectÃ© lors de la revue de code.',
    suggestion: 'Suggestion',
    verdictApprove: '**APPROUVÃ‰** - Le code peut Ãªtre fusionnÃ©',
    verdictRequestChanges: '**MODIFICATIONS REQUISES** - Veuillez corriger les problÃ¨mes',
    verdictComment: '**COMMENTAIRE** - Quelques suggestions Ã  considÃ©rer',
    footer: 'Cette revue a Ã©tÃ© gÃ©nÃ©rÃ©e par {models} et agrÃ©gÃ©e par {judge}.',
    cost: 'CoÃ»t estimÃ©',
  },
  es: {
    header: 'RevisiÃ³n de CÃ³digo IA',
    stats: 'EstadÃ­sticas',
    noFindings: 'Sin Problemas',
    noFindingsDesc: 'No se detectaron problemas significativos en la revisiÃ³n de cÃ³digo.',
    suggestion: 'Sugerencia',
    verdictApprove: '**APROBADO** - El cÃ³digo estÃ¡ listo para fusionar',
    verdictRequestChanges: '**CAMBIOS REQUERIDOS** - Por favor corrija los hallazgos',
    verdictComment: '**COMENTARIO** - Algunas sugerencias para considerar',
    footer: 'Esta revisiÃ³n fue generada por {models} y agregada por {judge}.',
    cost: 'Costo estimado',
  },
  pt: {
    header: 'RevisÃ£o de CÃ³digo IA',
    stats: 'EstatÃ­sticas',
    noFindings: 'Sem Problemas',
    noFindingsDesc: 'Nenhum problema significativo foi detectado na revisÃ£o de cÃ³digo.',
    suggestion: 'SugestÃ£o',
    verdictApprove: '**APROVADO** - CÃ³digo pronto para merge',
    verdictRequestChanges: '**ALTERAÃ‡Ã•ES NECESSÃRIAS** - Por favor corrija os problemas',
    verdictComment: '**COMENTÃRIO** - Algumas sugestÃµes para consideraÃ§Ã£o',
    footer: 'Esta revisÃ£o foi gerada por {models} e agregada por {judge}.',
    cost: 'Custo estimado',
  },
  zh: {
    header: 'AIä»£ç å®¡æŸ¥',
    stats: 'ç»Ÿè®¡',
    noFindings: 'æ— é—®é¢˜',
    noFindingsDesc: 'ä»£ç å®¡æŸ¥ä¸­æœªæ£€æµ‹åˆ°é‡è¦é—®é¢˜ã€‚',
    suggestion: 'å»ºè®®',
    verdictApprove: '**å·²æ‰¹å‡†** - ä»£ç å¯ä»¥åˆå¹¶',
    verdictRequestChanges: '**éœ€è¦æ›´æ”¹** - è¯·å¤„ç†å‘çŽ°çš„é—®é¢˜',
    verdictComment: '**è¯„è®º** - ä¸€äº›å»ºè®®ä¾›å‚è€ƒ',
    footer: 'æ­¤å®¡æŸ¥ç”±{models}ç”Ÿæˆï¼Œç”±{judge}æ±‡æ€»ã€‚',
    cost: 'é¢„ä¼°æˆæœ¬',
  },
  ko: {
    header: 'AI ì½”ë“œ ë¦¬ë·°',
    stats: 'í†µê³„',
    noFindings: 'ë¬¸ì œ ì—†ìŒ',
    noFindingsDesc: 'ì½”ë“œ ë¦¬ë·°ì—ì„œ ì¤‘ìš”í•œ ë¬¸ì œê°€ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
    suggestion: 'ì œì•ˆ',
    verdictApprove: '**ìŠ¹ì¸ë¨** - ì½”ë“œ ë³‘í•© ê°€ëŠ¥',
    verdictRequestChanges: '**ë³€ê²½ ìš”ì²­** - ë°œê²¬ëœ ë¬¸ì œë¥¼ ìˆ˜ì •í•´ ì£¼ì„¸ìš”',
    verdictComment: '**ì½”ë©˜íŠ¸** - ê³ ë ¤í•  ëª‡ ê°€ì§€ ì œì•ˆ',
    footer: 'ì´ ë¦¬ë·°ëŠ” {models}ì— ì˜í•´ ìƒì„±ë˜ê³  {judge}ì— ì˜í•´ ì§‘ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.',
    cost: 'ì˜ˆìƒ ë¹„ìš©',
  },
};

/**
 * Create Octokit instance
 */
function createOctokit(token: string): Octokit {
  return new Octokit({ auth: token });
}

/**
 * Format a finding as a markdown bullet point
 */
function formatFinding(finding: Finding, language: OutputLanguage = 'en'): string {
  const strings = UI_STRINGS[language] ?? UI_STRINGS.en;
  const severityEmoji = {
    critical: 'ðŸš¨',
    high: 'âš ï¸',
    medium: 'ðŸ“',
    low: 'ðŸ’¡',
    info: 'â„¹ï¸',
  };

  const emoji = severityEmoji[finding.severity];
  let text = `${emoji} **${finding.severity.toUpperCase()}**: ${finding.description}`;

  if (finding.file && finding.line) {
    text += ` (${finding.file}:${finding.line})`;
  }

  if (finding.suggestion) {
    text += `\n  - ðŸ’¡ ${strings.suggestion}: ${finding.suggestion}`;
  }

  return text;
}

/**
 * Format the final review as a markdown comment
 */
export function formatReviewComment(review: FinalReview, language: OutputLanguage = 'en'): string {
  const strings = UI_STRINGS[language] ?? UI_STRINGS.en;
  const headers = getSectionHeaders(language);
  const lines: string[] = [];

  // Header
  lines.push(`## ðŸ¤– ${strings.header}`);
  lines.push('');

  // Summary
  lines.push(`### ${headers.summary}`);
  lines.push(review.summary);
  lines.push('');

  // Stats
  lines.push(`### ${strings.stats}`);
  lines.push(`- ðŸš¨ Critical: ${review.stats.critical}`);
  lines.push(`- âš ï¸ High: ${review.stats.high}`);
  lines.push(`- ðŸ“ Medium: ${review.stats.medium}`);
  lines.push(`- ðŸ’¡ Low: ${review.stats.low}`);
  lines.push(`- â„¹ï¸ Info: ${review.stats.info}`);
  lines.push('');

  // Findings by severity
  if (review.findings.length > 0) {
    // Critical findings
    const critical = review.findings.filter((f) => f.severity === 'critical');
    if (critical.length > 0) {
      lines.push(`### ðŸš¨ ${headers.critical}`);
      critical.forEach((f) => lines.push(`- ${formatFinding(f, language)}`));
      lines.push('');
    }

    // High severity findings
    const high = review.findings.filter((f) => f.severity === 'high');
    if (high.length > 0) {
      lines.push(`### âš ï¸ ${headers.high}`);
      high.forEach((f) => lines.push(`- ${formatFinding(f, language)}`));
      lines.push('');
    }

    // Medium severity findings
    const medium = review.findings.filter((f) => f.severity === 'medium');
    if (medium.length > 0) {
      lines.push(`### ðŸ“ Medium Priority`);
      medium.forEach((f) => lines.push(`- ${formatFinding(f, language)}`));
      lines.push('');
    }

    // Low severity findings
    const lowAndInfo = review.findings.filter(
      (f) => f.severity === 'low' || f.severity === 'info'
    );
    if (lowAndInfo.length > 0) {
      lines.push(`### ðŸ’¡ ${headers.low}`);
      lowAndInfo.forEach((f) => lines.push(`- ${formatFinding(f, language)}`));
      lines.push('');
    }
  } else {
    lines.push(`### âœ… ${strings.noFindings}`);
    lines.push(strings.noFindingsDesc);
    lines.push('');
  }

  // Verdict
  lines.push(`### ${headers.verdict}`);
  const verdictText = {
    approve: `âœ… ${strings.verdictApprove}`,
    'request-changes': `ðŸ”„ ${strings.verdictRequestChanges}`,
    comment: `ðŸ’¬ ${strings.verdictComment}`,
  };
  lines.push(verdictText[review.verdict]);
  lines.push('');

  // Footer
  lines.push('---');
  const footerText = strings.footer
    .replace('{models}', review.contributingModels.join(', '))
    .replace('{judge}', review.judgeModel);
  lines.push(`*${footerText}*`);
  lines.push(`*${strings.cost}: $${review.estimatedCost.toFixed(4)}*`);

  return lines.join('\n');
}

/**
 * Post a summary comment on the PR
 */
export async function postSummaryComment(
  config: GitHubConfig,
  review: FinalReview,
  language: OutputLanguage = 'en'
): Promise<void> {
  const octokit = createOctokit(config.token);
  const body = formatReviewComment(review, language);

  logger.info('Posting summary comment', {
    owner: config.owner,
    repo: config.repo,
    prNumber: config.prNumber,
  });

  await octokit.issues.createComment({
    owner: config.owner,
    repo: config.repo,
    issue_number: config.prNumber,
    body,
  });

  logger.info('Summary comment posted successfully');
}

/**
 * Post a PR review with optional inline comments
 */
export async function postPRReview(
  config: GitHubConfig,
  review: FinalReview,
  commitSha: string,
  options: PostCommentOptions = { asReview: true, includeInlineComments: false },
  language: OutputLanguage = 'en'
): Promise<void> {
  const octokit = createOctokit(config.token);

  // Map verdict to GitHub review event
  const eventMap: Record<FinalReview['verdict'], 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT'> = {
    approve: 'APPROVE',
    'request-changes': 'REQUEST_CHANGES',
    comment: 'COMMENT',
  };

  const event = options.event ?? eventMap[review.verdict];
  const body = formatReviewComment(review, language);

  // Build inline comments if requested
  const comments: ReviewComment[] = [];
  if (options.includeInlineComments) {
    for (const finding of review.findings) {
      if (finding.file && finding.line) {
        comments.push({
          path: finding.file,
          line: finding.line,
          body: formatFinding(finding, language),
          side: 'RIGHT',
        });
      }
    }
  }

  logger.info('Posting PR review', {
    owner: config.owner,
    repo: config.repo,
    prNumber: config.prNumber,
    event,
    inlineComments: comments.length,
  });

  await octokit.pulls.createReview({
    owner: config.owner,
    repo: config.repo,
    pull_number: config.prNumber,
    commit_id: commitSha,
    body,
    event,
    comments: comments
      .filter((c) => c.path && c.line && c.side)
      .map((c) => ({
        path: c.path!,
        line: c.line!,
        body: c.body,
        side: c.side!,
      })),
  });

  logger.info('PR review posted successfully');
}

/**
 * Post the review to GitHub (auto-selects best method)
 */
export async function postToGitHub(
  config: GitHubConfig,
  review: FinalReview,
  commitSha?: string,
  language: OutputLanguage = 'en'
): Promise<void> {
  if (commitSha) {
    // Post as a PR review if we have commit SHA
    await postPRReview(config, review, commitSha, {
      asReview: true,
      includeInlineComments: false,
    }, language);
  } else {
    // Fallback to summary comment
    await postSummaryComment(config, review, language);
  }
}
